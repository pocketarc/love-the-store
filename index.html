<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Vue State Management: Data Down, Events Up</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Comic+Neue:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Rubik:ital,wght@0,300..900;1,300..900&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="plugin/highlight/github.css">

		<style>
            :root {
                --r-background-color: rgb(211, 69, 50);
                --r-main-font-size: 38px;
                --r-main-color: white;
                --r-heading-color: white;
                --r-main-font: "Rubik";
                --r-heading-font: "Rubik";
            }

            .reveal pre.code-sm {
                font-size: 0.4em;
                line-height: 1.2;
            }

            .reveal pre.code-xs {
                font-size: 0.3em;
                line-height: 1.2;
            }

            /* Split columns */
            .columns {
                display: flex;
                justify-content: space-between;
            }

            .column {
                flex-grow: 1;
	            flex-shrink: 1;
            }
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Vue State Management</h1>
					<h3>Data Down, Events Up</h3>
				</section>

				<section>
					<h2>Thinking in Vue</h2>
					<div class="columns">
						<div class="column" style="min-width: 520px;">
							<h3>PHP / Laravel</h3>
							<pre class="code-sm"><code class="php">// Controller
public function index()
{
    $users = User::all();
    return view('users.index', compact('users'));
}

// Blade template
@foreach($users as $user)
    <div>{{ $user->name }}</div>
@endforeach</code></pre>
						</div>
						<div class="column">
							<h3>Vue</h3>
							<pre class="code-sm"><code class="javascript">// Component
computed: {
  users() {
    return this.$store.state.users
  }
}

// Template
&lt;template&gt;
  &lt;div v-for="user in users"&gt;
    {{ user.name }}
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
						</div>
					</div>
					<p>From "get and show" to "declare and react"</p>
				</section>

				<section>
					<section>
						<h2>The Core Principle</h2>
						<h1 class="fragment">Data flows down</h1>
						<h1 class="fragment">Events bubble up</h1>
					</section>

					<section>
						<h3>Data Down</h3>
						<pre><code class="javascript">// In the parent
computed: {
  ...mapState(['visitData'])
}

// In the template
&lt;visit-details
  :visit="visitData"
  @update="handleUpdate"
/&gt;</code></pre>
					</section>

					<section>
						<h3>Events Up</h3>
						<pre><code class="javascript">// In the child component
methods: {
  updateVisit() {
    this.$emit('update', {
      id: this.visit.id,
      changes: this.changes
    })
  }
}</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h2>The Store as<br />Single Source of Truth</h2>
						<div style="text-align: center; font-size: 1em; line-height: 1.8;">
							<div style="font-size: 0.8em;line-height: 1.4">â†’ mutations</div>
							<div style="font-size: 0.8em;line-height: 1.4">â†’ API requests</div>
							<div style="font-weight: bold;">Store</div>
							<div style="font-size: 0.8em;line-height: 1.4">â†“ state</div>
							<div style="font-size: 0.8em;line-height: 1.4">â†“ getters</div>
							<div style="font-size: 0.8em;line-height: 1.4">â†‘ events/actions</div>
							<div style="font-weight: bold;">Components</div>
						</div>
					</section>

					<section>
						<h3>Data Flows Down: State & Loading</h3>
						<div class="columns">
							<div class="column">
                <pre class="code-sm"><code class="javascript">// In the store
state: {
  visits: {
    data: [],
    status: 'idle',
    error: null
  }
},
getters: {
  isLoading: state =>
    state.visits.status === 'loading',
  sortedVisits: state =>
    [...state.visits.data].sort(...)
}</code></pre>
							</div>
							<div class="column">
                <pre class="code-sm"><code class="javascript" style="min-width: 425px;">// In the component
computed: {
  ...mapState({
    visits: state => state.visits.data
  }),
  ...mapGetters(['isLoading', 'sortedVisits'])
}

// Template
&lt;template&gt;
  &lt;div&gt;
    &lt;loading-spinner v-if="isLoading" /&gt;
    &lt;visit-list
      v-else
      :visits="sortedVisits"
    /&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
							</div>
						</div>
					</section>

					<section>
						<h3>Events Bubble Up: Actions</h3>
						<div class="columns">
							<div class="column">
                <pre class="code-sm"><code class="javascript">// In the component
methods: {
  async handleVisitUpdate(changes) {
    // Event bubbles up as an action
    await this.$store.dispatch(
      'updateVisit',
      changes
    )
  }
}</code></pre>
							</div>
							<div class="column">
                <pre class="code-sm"><code class="javascript" style="min-width: 490px;">// In the store
actions: {
  async updateVisit({ commit }, changes) {
    commit('setStatus', 'loading')
    try {
      const response = await api.updateVisit(changes)
      commit('updateVisitData', response.data)
      commit('setStatus', 'success')
    } catch (error) {
      commit('setError', error)
      commit('setStatus', 'error')
    }
  }
}</code></pre>
							</div>
						</div>
						<p class="fragment">Components dispatch actions, store handles the complexity</p>
					</section>
				</section>

				<section>
					<h2>Common State Management Pitfalls</h2>
					<p>Learning Vue reactive patterns takes time</p>
				</section>

				<section>
					<section>
						<h3>Pattern 1: Direct State Access</h3>
						<pre><code class="javascript">// A natural first approach:
actions: {
  async loadVisits({ state }) {
    const url = `${config.apiUrl}/visits`
    const { data } = await axios.get(url)
    state.visits = data
  }
}</code></pre>
						<div>
							<p>Why this pattern needs evolution:</p>
							<ul>
								<li>Makes debugging more challenging</li>
								<li>Harder to track state changes</li>
								<li>Testing becomes more complex</li>
								<li>Misses Vue's reactivity benefits</li>
							</ul>
						</div>
					</section>

					<section>
						<h3>The Reactive Approach</h3>
						<pre><code class="javascript">mutations: {
  setVisits(state, visits) {
    state.visits = visits
  }
},
actions: {
  async loadVisits({ commit }) {
    const url = `${config.apiUrl}/visits`
    const { data } = await axios.get(url)
    commit('setVisits', data)
  }
}</code></pre>
						<p>Benefits: Trackable changes, easier debugging, better testing</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Pattern 2: Component-Level Data Management</h3>
						<pre><code class="javascript">// Starting point: Component handling everything
watch: {
  '$store.state.visits.0': {
    async handler(visitId) {
      if (!visitId) {
        this.loading = true
        return
      }
      this.loading = true
      const { data } = await this.loadVisits(...)
      this.tableData = data
      this.loading = false
    },
    immediate: true,
  }
}</code></pre>
						<p class="fragment">This pattern mixes concerns: state management, data fetching, and loading states</p>
					</section>

					<section>
						<h3>Better: Delegating to the Store</h3>
						<pre><code class="javascript">computed: {
  ...mapState({
    firstVisitId: state => state.visits[0]
  })
},
methods: {
  ...mapActions(['handleFirstVisitChange'])
},
watch: {
  firstVisitId: {
    immediate: true,
    handler() {
      this.handleFirstVisitChange()
    }
  }
}</code></pre>
					</section>

					<section>
						<h3>Best: Embracing Reactivity</h3>
						<div class="columns">
							<div class="column">
								<pre class="code-sm"><code class="javascript" style="min-width: 400px;">export default {
  computed: {
    ...mapState(['visitData', 'isLoading'])
  },
  created() {
    // Component asks for what it needs
    this.$store.dispatch('loadVisitData')
  }
}</code></pre>
							</div>
							<div class="column">
								<pre class="code-sm"><code class="javascript" style="min-width: 480px;">// In the store
actions: {
  async loadVisitData({ commit, state }) {
    if (state.isLoading) {
        return
    }

    commit('setLoading', true)
    try {
      const data = await api.getVisitData(visitId)
      commit('setVisitData', data)
    } finally {
      commit('setLoading', false)
    }
  }
}</code></pre>
							</div>
						</div>
						<p>Benefits:</p>
						<ul>
							<li>Simpler component code</li>
							<li>No watchers needed</li>
							<li>Clear separation of concerns</li>
							<li>Store handles all data management</li>
						</ul>
					</section>

						<section>
							<h3>Pattern 3: Incomplete Error Handling</h3>
							<pre class="code-sm"><code class="javascript">// Missing error handling completely
actions: {
  async loadVisits({ commit }) {
    const { data } = await axios.get('/api/visits')
    commit('setVisits', data)
    // Request fails? User sees nothing or infinite spinner
  }
}</code></pre>
							<pre class="code-sm"><code class="javascript">// Or mixing UI concerns in the store
actions: {
  async loadVisits({ commit }) {
    try {
      const { data } = await axios.get('/api/visits')
      commit('setVisits', data)
    } catch (error) {
      // UI doesn't belong in the store! ðŸ˜±
      this.$toast.error('Failed to load visits')
    }
  }
}</code></pre>
						</section>

						<section>
							<h3>The Reactive Approach</h3>
							<pre class="code-sm"><code class="javascript">// In the store: Handle state, not UI
actions: {
  async loadVisits({ commit }) {
    commit('setStatus', 'loading')
    try {
      const { data } = await axios.get('/api/visits')
      commit('setVisits', data)
      commit('setStatus', 'success')
    } catch (error) {
      commit('setError', error)
      commit('setStatus', 'error')
    }
  }
},</code></pre>
							<pre class="code-sm"><code class="javascript">// In the component: Handle UI
computed: {
  ...mapState({
    error: state => state.visits.error,
    status: state => state.visits.status
  })
},
watch: {
  error(error) {
    if (error) {
      this.$toast.error('Failed to load visits')
    }
  }
}</code></pre>
						</section>

				</section>

				<section>
					<section>
						<h2>See It, Code It, Sort It</h2>
						<p>Next time you're working on a component...</p>
						<img src="assets/see-it-say-it-sorted.jpg" alt="See it, say it, sorted" style="height: 300px">
					</section>

					<section>
						<h3>When You See: Direct API Calls</h3>
						<pre><code class="javascript">// You see this:
async mounted() {
  const { data } = await axios.get('/api/visits')
  this.visits = data
}</code></pre>
						<pre class="fragment"><code class="javascript">// Code this instead:
created() {
  this.$store.dispatch('loadVisits')
}</code></pre>
						<p class="fragment">Sorted: Store handles data fetching,<br />component stays clean</p>
					</section>

					<section>
						<h3>When You See: Watchers Updating Data</h3>
						<div class="columns">
							<div class="column">
                <pre class="code-sm"><code class="javascript">// You see this:
data() {
  return { filtered: [] }
},
watch: {
  visits() {
    this.filtered = this.visits.filter(...)
  }
}</code></pre>
							</div>
							<div class="column">
                <pre class="fragment code-sm"><code class="javascript">// Code this instead:
computed: {
  filtered() {
    return this.visits.filter(...)
  }
}</code></pre>
							</div>
						</div>
						<p class="fragment">Sorted: Let Vue's reactivity system do the work</p>
					</section>

					<section>
						<h3>When You See: Component-Managed State</h3>
						<div class="columns">
							<div class="column">
                <pre class="code-sm"><code class="javascript">// You see this:
data() {
  return {
    visits: [],
    loading: false,
    error: null
  }
},
async mounted() {
  this.loading = true
  try {
    this.visits = await this.loadVisits()
  } catch (e) {
    this.error = e
  }
  this.loading = false
}</code></pre>
							</div>
							<div class="column">
                <pre class="fragment code-sm"><code class="javascript">// Code this instead:
computed: {
  ...mapState({
    loading: (state) => {
      return state.visits.status === 'loading'
    },
    error: (state) => {
      return state.visits.error
    }
  })
},
created() {
  this.$store.dispatch('loadVisits')
}</code></pre>
							</div>
						</div>
						<p class="fragment">Sorted: Clean components, centralized state management</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Advanced Patterns</h2>
					</section>

					<section>
						<h3>Smarter Data Flow</h3>
                <pre class="code-sm"><code class="javascript">// Instead of multiple getters...
getActiveVisits: state => state.visits.filter(v => v.active),
getCompletedVisits: state => state.visits.filter(v => v.completed),

// One flexible getter
getVisitsByStatus: state => status => state.visits.filter(v => v.status === status)</code></pre>
                <pre class="code-sm"><code class="javascript">// In components
computed: {
  activeVisits() {
    return this.$store.getters.getVisitsByStatus('active')
  },
  completedVisits() {
    return this.$store.getters.getVisitsByStatus('completed')
  }
}</code></pre>
						<p class="fragment">DRY state access with flexible getters</p>
					</section>

					<section>
						<h3>Coordinated Actions</h3>
						<pre><code class="javascript">actions: {
  // Orchestrate complex workflows
  async initializeApp({ dispatch }) {
    await dispatch('loadUser')  // Must load first

    // These can load in parallel
    await Promise.all([
      dispatch('loadVisits'),
      dispatch('loadSettings'),
      dispatch('loadPreferences')
    ])
  }
}</code></pre>
						<p class="fragment">Compose actions for complex flows while keeping components simple</p>
					</section>

					<section>
						<h3>Global State Management</h3>
						<pre><code class="javascript">// Handle loading and errors consistently
store.subscribeAction({
  before: (action) => {
    if (action.type.startsWith('load')) {
      startLoadingIndicator()
    }
  },
  after: (action) => {
    if (action.type.startsWith('load')) {
      stopLoadingIndicator()
    }
  },
  error: (action, error) => {
    handleError(error)
  }
})</code></pre>
						<p class="fragment">Consistent behavior across all store interactions</p>
					</section>

					<section>
						<h3>Rich State Objects</h3>

						<div class="columns">
							<div class="column">
<pre class="code-sm"><code class="javascript">// Instead of scattered state
state: {
  visits: [],
  selectedVisitId: null,
  isLoading: false,
  error: null,
  sortDirection: 'asc'
}

// Group related state
state: {
  visits: {
    data: [],
    selected: null,
    status: 'idle',
    error: null,
    sortConfig: {
      field: 'date',
      direction: 'asc'
    }
  }
}</code></pre>
							</div>
							<div class="column">
<pre class="code-sm"><code class="javascript" style="min-width: 520px;">// In components
computed: {
  visits() {
	  return this.$store.state.visits
  },
  sortedVisits() {
    const { field, direction } = this.visits.sortConfig
    return [...this.visits.data].sort((a, b) => {
      if (direction === 'asc') {
        return a[field].localeCompare(b[field])
      } else {
        return b[field].localeCompare(a[field])
      }
    })
  }
}</code></pre>
							</div>
						</div>
						<p class="fragment">Cohesive state management enables cleaner components</p>
					</section>
				</section>

				<section>
					<h3>Remember:</h3>
					<ul>
						<li class="fragment">Data flows down, events bubble up</li>
						<li class="fragment">Components show things, stores do things</li>
						<li class="fragment">Mutations make debugging possible</li>
						<li class="fragment">Better patterns = better user experience</li>
					</ul>
				</section>

				<section>
					<h2>Thank You!</h2>
					<img src="assets/be-like-bill.png" alt="Be like bill" style="height: 460px !important">
					<p class="fragment" style="margin-top: -0.5em;">Special thanks to Kaitlyn Concilio for the support. Without her I wouldn't be here giving you this TED talk.</p>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Show line numbers in code
				highlight: {
					lineNumbers: true
				},
				// Enable slide animations
				transition: 'slide',

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
			});
		</script>
	</body>
</html>
